- title: Глава 1 - Что такое WebAssembly?
  content_markdown: >
    WebAssembly - это двоичный формат для представления изолированного исполняемого кода. 
    Он был разработан для веб-браузеров в качестве альтернативы JavaScript с некоторыми преимуществами:

    * Поскольку это низкоуровневый байткод, он способен быстро выполнять математические вычисления и
    управлять памятью более эффективно.

    * WebAssembly был создан с учетом существующих компиляторов, что позволяет нативным
    языкам, таким как C/C++ и Rust, компилироваться в него напрямую.

    * Построен с учетом изоляции, что позволяет осуществлять детальный контроль доступа к памяти.

    * WebAssembly была создана независимой от исполняемой среды, что также позволяет использовать
    WebAssembly [вне браузеров](https://wasmer.io/)!


    WebAssembly часто называют просто **WASM**
- title: О модулях
  content_markdown: >
    При компиляции WebAssembly ваш компилятор должен создать файл
    с расширением `.wasm`, называемый **модулем**.

    Модуль представляет собой [двоичный
    формат](https://webassembly.github.io/spec/core/index.html), который содержит информацию о том, как

    wasm-программа и ее память должны быть настроены и взаимодействовать с:

    * списком функций

    * какие функции должны быть экспортированы/импортированы

    * какие данные должны изначально находиться в памяти модулей wasm
- title: Загрузка модуля
  content_markdown: >
    Так как WebAssembly-модуль представляет из себя двоичный файл, сперва мы должны загрузить
      его в наш браузер


    ```

    let file = await fetch('my_file.wasm');

    let bytes = await file.arrayBuffer();

    ```
- title: Инициализация модуля
  content_markdown: >
    Модуль инициализируется из байтов.


    ```

    let module = await WebAssembly.instantiate(bytes);

    ```


    На этом этапе мы можем **импортировать** функции JavaScript, к которым мы хотим предоставить доступ нашему модулю. 

    Мы покажем это на примере в следующей главе.
- title: Использование модуля
  content_markdown: >
    Модуль будет иметь одну или несколько **внешних** функций, доступных из
    JavaScript. Обычно

    для запуска wasm-модуля необходимо вызвать некоторую внешную функцию. (например,
    `main`, `start` и т.дю).


    ```

    module.instance.main();

    ```
- title: 1+1
  code: "https://webassembly.studio/?embed&f=jg96xg1ovj"
  content_markdown: >
    Давайте соберем все наши знания воедино и создадим WebAssembly

    модуль с единственной **внешней** функцией `add`, которая будет складывать два числа, и попробуем
    вывести результат на страницу HTML.


    `#[no_mangle]` говорит компилятору не менять имя функции во время сборки.
- title: Глава 1 Вывод
  content_markdown: >
    Надеюсь, после прочтения вам стало ясно, что WebAssembly не так уж и сложен в своей основе! В нашей
    следующей главе мы 

    начнем изучать детали того, как JavaScript и WebAssembly могут взаимодействовать через одни и те же данные.
