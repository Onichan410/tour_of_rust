- title: Глава 2 - Обмен данными
  content_markdown: >
    JavaScript и WebAssembly совершенно по-разному строят свою работу с памятью.

    Что еще больше усложняет ситуацию, взаимодействие с JavaScript из
    WebAssembly очень ограничено.

    В этой главе мы рассмотрим стратегии, используемые для перемещения данных туда и обратно.
- title: Импортирование функций
  code: "https://webassembly.studio/?embed&f=pp20eedhka"
  content_markdown: >
    Модули WebAssembly могут вызывать только те функции, которые были явно
    импортированы.


    Rust использует ключевые слова `extern "C" { ... }` для перечисления сигнатур этих
    импортированных функций.


    Обратите внимание, что вызов импортированной функции считается в Rust `небезопасным`.
    потому что компилятор


    не может дать никаких гарантий относительно того, что произойдет внутри ее реализации.
- title: Ограничения функций
  content_markdown: >
    Типы параметров и возвращаемых значений функций ограничены:

    * i32/i64

    * f32/f64


    Таким образом, для взаимодействия между JavaScript и WebAssembly нам придется
    разобраться, как перевести наши данные в числа!


    Rust достаточно хорошо справляется с преобразованием примитивных типов в числовые эквиваленты WebAssembly.
- title: О памяти
  content_markdown: >
    Память в WebAssembly можно представить как непрерывную последовательность из байтов. (до
    4 ГБ!).


    JavaScript может интерпретировать из этих байтов нужные структуры данных.


    Массивы байтов также могут быть записаны непосредственно в память программы при помощи
      JavaScript.


    Запись/чтение байтов в/из памяти программ на WebAssembly является

    основным средством ввода и вывода для сложных типов.
- title: ArrayBuffer
  content_markdown: |
    JavaScript представляет длинный массив байтов как `ArrayBuffer`.

    Вы можете получить типизированное представление этого буфера, с которым сможете более
      эффективно взаимодействовать

    ```JavaScript
    // Создаем массив из 8 байтов
    let bytes = new ArrayBuffer(8);
    // Интерпретируем его в качестве массива безнаковых 8-битовых чисел
    let u8_bytes = new Uint8Array(bytes);
    // Изменяем пару значений
    u8_bytes[0] = 16; // 00010000
    u8_bytes[1] = 1;  // 00000001
    // Результат снова интерпретируем,
    // теперь в массив 32-битных чисел со знаком
    let i32_bytes = new Int32Array(u8_bytes.buffer);
    console.log(i32_bytes[0]); 
    ///272 or 00010000000000010000000000000000
    ```
- title: UTF-8 Кодирование/Декодирование
  content_markdown: >
    JavaScript предоставляет вспомогательные функции для записи/чтения строк UTF-8
    в/из

    байтов внутри `ArrayBuffer`.


    ```JavaScript

    let bytes = new ArrayBuffer(8);

    const data = new Uint8Array(bytes);

    data[0] = 72;  // H

    data[1] = 105; // i

    data[2] = 33;  // !

    let str_len = 3;

    const utf8dec = new TextDecoder("utf-8");

    // subarray() берет подмассив с заданым промежутком

    let text = utf8dec.decode(data.subarray(0,str_len));

    console.log(text) // Hi!


    const utf8enc = new TextEncoder("utf-8");

    let text_bytes = utf8enc.encode(text);

    console.log(text_bytes) 

    // Uint8Array(3) [72, 105, 33]

    ```
- title: Logging Text
  code: "https://webassembly.studio/?embed&f=1gxcr004p3x"
  content_markdown: >
    Let's explore a simple example of logging some text from a WebAssembly
    program.


    We must:

    1. Create some utf-8 compliant text in our program's memory

    2. Determine the length of our text's bytes

    3. Somehow send the starting byte start index and length in bytes of that
    text data to the host browser so it can call `console.log`.


    Here's an example of what that receiving JavaScript function would look
    like:


    ```JavaScript

    wasm_log(start,len) {
      // extract text from memory location and length
      const utf8dec = new TextDecoder("utf-8");
      let buffer = module.instance.exports.memory.buffer;
      let memory = new Uint8Array(buffer);
      let text = utf8dec.decode(memory.subarray(start,start+len));
      console.log(text);
    }

    ```
- title: Reading Text
  code: "https://webassembly.studio/?embed&f=ubmxmavgf2"
  content_markdown: >
    Let's explore the opposite idea. Imagine we want to give some text to a
    WebAssembly program.


    We must:

    1. Determine the length in bytes of the text we want to pass in.

    1. Allocate some space in our memory of that byte length.

    2. Copy bytes into our program's memory at the start of the space we
    allocated.

    3. Let the WebAssembly program know we have put some data in it's memory at
    a specific index and lenth in bytes. 


    Here's an example of what that initialization looks like:


    ```JavaScript

    // Turn "Ferris" into bytes

    const utf8enc = new TextEncoder("utf-8");

    let text = "Ferris";

    let text_bytes = utf8enc.encode(text);


    // Allocate enough space for the text

    let len = text_bytes.length;

    let start = module.instance.exports.wasm_malloc(len);


    // Put the text in WebAssembly program's memory

    let buffer = module.instance.exports.memory.buffer;

    let memory = new Uint8Array(buffer);

    memory.set(text_bytes, start);


    // Run the program

    module.instance.exports.main(start,len);

    ```
- title: Discovering Representations
  content_markdown: >
    You might find it annoying to pass around the length along with the start
    index of text.


    Consider this an opportunity to reflect upon useful conventions of the past
    like *C strings*

    that declare the end of text is a 0 value character `\0`.


    Don't want to pass around a byte packed data structure? Consider passing
    around json.


    You are in control of your representations in memory and what they mean and
    if they

    are appropriate for your use cases!
- title: Chapter 2 Conclusion
  content_markdown: >
    Crossing the boundry between host and WebAssembly program is cumbersome, but
    with it can come great performance. 

    It's important to remind ourselves that WebAssembly is a low -level
    executable byte code with concerns about memory

    structures that are much fine-grained than JavaScript. Check out your
    programming language's

    library support for tools that help make this an easier task! For Rust,
    [wasm-bindgen](https://github.com/rustwasm/wasm-bindgen) is a popular
    option.


    In our next chapter we will talk about a technique for dynamically calling
    JavaScript functions and garbage collection!
